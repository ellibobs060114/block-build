<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tetris — HTML5 Canvas</title>
  <style>
    :root{
      --bg:#0f1724; --panel:#0b1220; --accent:#22c55e; --muted:#9ca3af;
    }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;}
    body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#071127 0%, #0b1530 100%);color:#e6eef8}
    .wrap{display:grid;grid-template-columns:320px 220px;gap:20px;align-items:start;padding:28px}
    .board{background:var(--panel);border-radius:12px;padding:18px;box-shadow:0 6px 30px rgba(2,6,23,0.6)}
    canvas{display:block;background:linear-gradient(180deg,#071227 0,#05203a 100%);border-radius:6px}
    .hud{background:linear-gradient(180deg,#071127,#071827);border-radius:12px;padding:18px;color:var(--muted);min-height:200px}
    h1{margin:0 0 8px 0;font-size:18px;color:#e6eef8}
    .stats{display:flex;flex-direction:column;gap:8px;margin-top:12px}
    .stat{display:flex;justify-content:space-between;align-items:center;font-size:14px;color:var(--muted)}
    .controls{margin-top:12px;font-size:13px}
    .btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:8px;color:var(--muted);cursor:pointer}
    .small{font-size:12px;color:#9fb8c2}
    footer{grid-column:1/-1;text-align:center;color:#6b7280;margin-top:8px;font-size:12px}
    .next, .hold{display:flex;gap:8px;align-items:center}
    .mini{width:80px;height:80px;background:rgba(255,255,255,0.02);display:grid;place-items:center;border-radius:8px}
    .center-col{display:flex;flex-direction:column;gap:10px}
    .accent{color:var(--accent)}
    @media (max-width:760px){.wrap{grid-template-columns:1fr;}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="board">
      <h1>Block Build!</h1>
      <canvas id="game" width="240" height="480"></canvas>
      <div style="display:flex;gap:8px;margin-top:10px;align-items:center">
        <button id="btnDrop" class="btn">Drop</button>
        <button id="btnPause" class="btn">Pause (P)</button>
        <button id="btnReset" class="btn">Restart (R)</button>
        <div class="small" style="margin-left:auto">Score: <span id="scr">0</span></div>
      </div>
    </div>

    <div class="hud">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div class="small">Next</div>
          <div class="mini" id="next"></div>
        </div>
        <div>
          <div class="small">Hold</div>
          <div class="mini" id="hold"></div>
        </div>
      </div>

      <div class="stats">
        <div class="stat"><span>Level</span><strong id="lv">1</strong></div>
        <div class="stat"><span>Lines</span><strong id="lines">0</strong></div>
        <div class="stat"><span>Score</span><strong id="score">0</strong></div>
        <div class="stat"><span>Drop speed</span><strong id="speed">1</strong></div>
      </div>

      <div class="controls">
        <div class="small">Controls</div>
        <ul style="margin:6px 0 0 18px;color:var(--muted)">
          <li>← Move left</li>
          <li>→ Move right</li>
          <li>↑ Rotate</li>
          <li>↓ Soft drop</li>
          <li>Space Hard drop</li>
          <li>Shift Hold</li>
          <li>P Pause</li>
        </ul>
      </div>

      <div style="margin-top:12px;display:flex;gap:8px">
        <button id="soundBtn" class="btn">Toggle Sound</button>
        <button id="muteBtn" class="btn">Mute</button>
      </div>

      <div style="margin-top:16px;color:#7f9aa7;font-size:12px">
        A Simple, relaxing game! No download required! 
      </div>
    </div>

    <footer>Made by @pookie_wookie22 — enjoy! · Controls listed above</footer>
  </div>

  <script>
  // ===== Tetris — Single-file implementation =====
  // Grid: 10 x 20 standard
  const COLS = 10, ROWS = 20, BLOCK = 24; // block size used for drawing
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  canvas.width = COLS * BLOCK;
  canvas.height = ROWS * BLOCK;

  // HUD elements
  const nextCanvasContainer = document.getElementById('next');
  const holdCanvasContainer = document.getElementById('hold');
  const scoreEl = document.getElementById('score');
  const scrEl = document.getElementById('scr');
  const lvEl = document.getElementById('lv');
  const linesEl = document.getElementById('lines');
  const speedEl = document.getElementById('speed');

  // Create mini canvases for next/hold
  function makeMini(parent){
    const c = document.createElement('canvas'); c.width = 80; c.height = 80; parent.appendChild(c); return c.getContext('2d');
  }
  const nextCtx = makeMini(nextCanvasContainer);
  const holdCtx = makeMini(holdCanvasContainer);

  // Tetromino definitions (4x4 matrices)
  const SHAPES = {
    I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
    J: [[1,0,0],[1,1,1],[0,0,0]],
    L: [[0,0,1],[1,1,1],[0,0,0]],
    O: [[1,1],[1,1]],
    S: [[0,1,1],[1,1,0],[0,0,0]],
    T: [[0,1,0],[1,1,1],[0,0,0]],
    Z: [[1,1,0],[0,1,1],[0,0,0]]
  };
  const COLORS = {I:'#06b6d4',J:'#6366f1',L:'#f97316',O:'#eab308',S:'#10b981',T:'#7c3aed',Z:'#ef4444'};
  const BAG = ['I','J','L','O','S','T','Z'];

  // Game state
  let grid = createGrid(ROWS, COLS);
  let current = null; // {shape, x, y, matrix, color}
  let nextQueue = [];
  let holdPiece = null; let canHold = true;
  let score = 0, level = 1, lines = 0;
  let dropInterval = 1000; // ms
  let lastDrop = performance.now();
  let running = true;
  let gameOver = false;
  let soundOn = false;

  // Helpers
  function createGrid(r,c){ return Array.from({length:r}, ()=> Array(c).fill(0)); }
  function cloneMatrix(m){ return m.map(row=>row.slice()); }
  function rotate(matrix){ // rotate clockwise
    const N = matrix.length; const res = Array.from({length:N},()=>Array(N).fill(0));
    for(let y=0;y<N;y++) for(let x=0;x<N;x++) res[x][N-1-y] = matrix[y][x];
    // trim empty outer rows/cols to keep shape small when possible
    return trimMatrix(res);
  }
  function trimMatrix(m){
    // remove empty rows and cols around the block
    // remove empty top rows
    while(m.length>0 && m[0].every(v=>v===0)) m.shift();
    while(m.length>0 && m[m.length-1].every(v=>v===0)) m.pop();
    // remove empty left/right columns
    const width = m[0] ? m[0].length : 0;
    let leftEmpty = true, rightEmpty = true;
    for(let y=0;y<m.length;y++){
      if(m[y][0]) leftEmpty = false;
      if(m[y][width-1]) rightEmpty = false;
    }
    if(leftEmpty) m = m.map(r=>r.slice(1));
    if(rightEmpty) m = m.map(r=>r.slice(0,-1));
    return m;
  }

  function newPiece(type){
    const mat = cloneMatrix(SHAPES[type]);
    return {type, matrix:mat, x: Math.floor((COLS - mat[0].length)/2), y: -mat.length, color:COLORS[type]};
  }

  function refillQueue(){
    // 7-bag shuffle
    let bag = BAG.slice();
    for(let i=bag.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[bag[i],bag[j]]=[bag[j],bag[i]]}
    nextQueue.push(...bag.map(t=>newPiece(t)));
  }

  // initialize queue
  refillQueue(); if(nextQueue.length<14) refillQueue();
  current = nextQueue.shift();

  // Drawing routines
  function drawCell(ctx,x,y,color){
    ctx.fillStyle = color; ctx.fillRect(x*BLOCK,y*BLOCK,BLOCK-1,BLOCK-1);
    // subtle highlight
    ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.fillRect(x*BLOCK,y*BLOCK+2,BLOCK-2,6);
  }

  function draw(){
    // background
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // draw fixed grid
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        if(grid[r][c]) drawCell(ctx,c,r,grid[r][c]);
      }
    }
    // draw current piece
    if(current){
      const m = current.matrix; for(let y=0;y<m.length;y++) for(let x=0;x<m[0].length;x++){
        if(m[y][x]) drawCell(ctx, current.x + x, current.y + y, current.color);
      }
    }
    // grid lines (subtle)
    ctx.strokeStyle = 'rgba(255,255,255,0.02)'; ctx.lineWidth = 1;
    for(let c=0;c<=COLS;c++){ ctx.beginPath(); ctx.moveTo(c*BLOCK,0); ctx.lineTo(c*BLOCK,canvas.height); ctx.stroke(); }
    for(let r=0;r<=ROWS;r++){ ctx.beginPath(); ctx.moveTo(0,r*BLOCK); ctx.lineTo(canvas.width,r*BLOCK); ctx.stroke(); }

    // draw mini next/hold
    drawMini(nextCtx, nextQueue[0]);
    drawMini(holdCtx, holdPiece);
  }

  function drawMini(ctxMini, piece){
    ctxMini.clearRect(0,0,ctxMini.canvas.width,ctxMini.canvas.height);
    ctxMini.fillStyle = 'rgba(255,255,255,0.01)'; ctxMini.fillRect(0,0,ctxMini.canvas.width,ctxMini.canvas.height);
    if(!piece) return;
    const pad = 6; const cell = 14; const mat = piece.matrix;
    const w = mat[0].length, h = mat.length; const offX = Math.floor((ctxMini.canvas.width - w*cell)/2);
    const offY = Math.floor((ctxMini.canvas.height - h*cell)/2);
    for(let y=0;y<h;y++) for(let x=0;x<w;x++) if(mat[y][x]){
      ctxMini.fillStyle = piece.color; ctxMini.fillRect(offX + x*cell, offY + y*cell, cell-2, cell-2);
    }
  }

  // collision check
  function collides(mat, x, y){
    for(let r=0;r<mat.length;r++) for(let c=0;c<mat[0].length;c++){
      if(!mat[r][c]) continue;
      const gx = x + c, gy = y + r;
      if(gx < 0 || gx >= COLS || gy >= ROWS) return true;
      if(gy >= 0 && grid[gy][gx]) return true;
    }
    return false;
  }

  function placePiece(){
    const m = current.matrix; for(let r=0;r<m.length;r++) for(let c=0;c<m[0].length;c++){
      if(!m[r][c]) continue;
      const gx = current.x + c, gy = current.y + r;
      if(gy >= 0) grid[gy][gx] = current.color;
      else { // piece placed above grid -> game over
        gameOver = true; running = false; return;
      }
    }
    clearLines();
    current = nextQueue.shift(); if(nextQueue.length < 7) refillQueue();
    canHold = true;
  }

  function clearLines(){
    let cleared = 0;
    for(let r=ROWS-1;r>=0;r--){
      if(grid[r].every(c=>c!==0)){
        grid.splice(r,1); grid.unshift(Array(COLS).fill(0)); cleared++; r++; // check same row index again
      }
    }
    if(cleared>0){
      lines += cleared; score += scoreForLines(cleared); level = Math.floor(lines/10) + 1; dropInterval = Math.max(120, 1000 - (level-1)*70);
      scoreEl.textContent = score; scrEl.textContent = score; lvEl.textContent = level; linesEl.textContent = lines; speedEl.textContent = (1000/dropInterval).toFixed(2);
    }
  }

  function scoreForLines(n){
    const table = {1:40,2:100,3:300,4:1200}; return (table[n]||0) * level;
  }

  // movement handlers
  function move(dx){ if(!current) return; if(!collides(current.matrix, current.x + dx, current.y)) { current.x += dx; draw(); } }
  function rotateCurrent(){ if(!current) return; const rotated = rotate(current.matrix); // attempt wall kicks
    const kicks = [0, -1, 1, -2, 2]; for(const k of kicks){
      if(!collides(rotated, current.x + k, current.y)) { current.matrix = rotated; current.x += k; draw(); return; }
    }
  }

  function softDrop(){ if(!current) return; if(!collides(current.matrix, current.x, current.y+1)) { current.y += 1; score += 1; scoreEl.textContent = score; scrEl.textContent = score; } else { placePiece(); } draw(); }

  function hardDrop(){ if(!current) return; while(!collides(current.matrix, current.x, current.y+1)){ current.y++; score += 2; } placePiece(); draw(); }

  function hold(){ if(!current || !canHold) return; if(!holdPiece){ holdPiece = {type:current.type, matrix:cloneMatrix(SHAPES[current.type]), color:current.color}; current = nextQueue.shift(); if(nextQueue.length<7) refillQueue(); } else { // swap
    const tmp = holdPiece; holdPiece = {type:current.type, matrix:cloneMatrix(SHAPES[current.type]), color:current.color}; current = newPiece(tmp.type);
  }
    canHold = false; draw(); }

  // input
  const keys = {};
  document.addEventListener('keydown', e=>{
    if(e.repeat) return; keys[e.code]=true;
    switch(e.code){
      case 'ArrowLeft': move(-1); break;
      case 'ArrowRight': move(1); break;
      case 'ArrowUp': rotateCurrent(); break;
      case 'ArrowDown': softDrop(); break;
      case 'Space': hardDrop(); break;
      case 'ShiftLeft': case 'ShiftRight': hold(); break;
      case 'KeyP': togglePause(); break;
      case 'KeyR': resetGame(); break;
    }
  });
  document.addEventListener('keyup', e=>{ keys[e.code]=false; });

  // buttons
  document.getElementById('btnDrop').addEventListener('click', ()=> hardDrop());
  document.getElementById('btnPause').addEventListener('click', ()=> togglePause());
  document.getElementById('btnReset').addEventListener('click', ()=> resetGame());

  function togglePause(){ running = !running; if(running) { lastDrop = performance.now(); loop(); } }
  function resetGame(){ grid = createGrid(ROWS,COLS); nextQueue = []; refillQueue(); refillQueue(); current = nextQueue.shift(); holdPiece = null; canHold=true; score=0; level=1; lines=0; dropInterval=1000; running=true; gameOver=false; updateHUD(); draw(); lastDrop = performance.now(); }

  function updateHUD(){ scoreEl.textContent = score; scrEl.textContent = score; lvEl.textContent = level; linesEl.textContent = lines; speedEl.textContent = (1000/dropInterval).toFixed(2); }

  // main loop
  function loop(now){
    if(!running) return;
    if(gameOver){ // simple overlay
      ctx.fillStyle = 'rgba(2,6,23,0.75)'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#fff'; ctx.font='24px sans-serif'; ctx.textAlign='center'; ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 10);
      ctx.font='14px sans-serif'; ctx.fillText('Press R to restart', canvas.width/2, canvas.height/2 + 18);
      return;
    }
    if(!now) now = performance.now();
    const delta = now - lastDrop;
    if(delta > dropInterval){
      // gravity
      if(!collides(current.matrix, current.x, current.y+1)) current.y += 1;
      else placePiece();
      lastDrop = now;
      updateHUD();
    }
    draw();
    requestAnimationFrame(loop);
  }

  // start gently
  updateHUD(); draw(); lastDrop = performance.now(); requestAnimationFrame(loop);

  // expose a simple API to window for debugging
  window._tetris = {grid, current, nextQueue, holdPiece, resetGame};
  </script>
</body>
</html>

